#!/usr/bin/env python3
"""
Enforce per-file coverage thresholds.

Expects a ``coverage.xml`` report generated by ``coverage.py`` / ``pytest-cov``.
"""

from __future__ import annotations

import argparse
import json
import sys
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Any

# Explicit per-file overrides. Values are branch floors unless branch-rate is
# unavailable, in which case line-rate is used as a fallback. These take
# precedence over the global/core floors below. Set all to 85% now that suites
# are in place.
THRESHOLDS = {
    # Evaluation & reporting
    "src/invarlock/eval/metrics.py": 0.85,
    # Reporting
    "src/invarlock/reporting/certificate.py": 0.85,
    "src/invarlock/reporting/report.py": 0.85,
    "src/invarlock/reporting/validate.py": 0.85,
    # Reporting types
    "src/invarlock/reporting/report_types.py": 0.85,
    # Guards (safety mechanisms)
    "src/invarlock/guards/variance.py": 0.85,
    "src/invarlock/guards/invariants.py": 0.85,
    "src/invarlock/guards/spectral.py": 0.85,
    "src/invarlock/guards/rmt.py": 0.85,
    "src/invarlock/guards/policies.py": 0.85,
    # Core orchestration & runtime
    "src/invarlock/core/runner.py": 0.85,
    "src/invarlock/core/registry.py": 0.85,
    # Omit bootstrap here due to ambiguous bare-filename records in coverage.xml
    # "src/invarlock/core/bootstrap.py": 0.85,
    "src/invarlock/core/contracts.py": 0.85,
    "src/invarlock/core/auto_tuning.py": 0.85,
    # Newly added core modules to critical surface
    "src/invarlock/core/checkpoint.py": 0.85,
    "src/invarlock/core/api.py": 0.85,
    "src/invarlock/core/retry.py": 0.85,
    "src/invarlock/core/types.py": 0.85,
    # CLI commands
    "src/invarlock/cli/commands/run.py": 0.85,
    "src/invarlock/cli/commands/verify.py": 0.85,
    # Core events logger
    "src/invarlock/core/events.py": 0.85,
}

# Default floors (applied only to core classification; non-core modules are not
# globally enforced unless explicitly listed in THRESHOLDS)
CORE_FLOOR_DEFAULT = 0.85
DEFAULT_FLOOR_DEFAULT = 0.85

# Core module classification: files matching any of these prefixes are treated
# as part of the critical surface and must meet the core floor (unless an
# explicit override in THRESHOLDS is present).
# NOTE: Keep this aligned with CONTRIBUTING.md "Coverage Policy" and update
# incrementally as the surface evolves.
CORE_PREFIXES = (
    # Core orchestration & runtime
    "src/invarlock/core/",
    # Guards (safety mechanisms)
    "src/invarlock/guards/",
)

# Individual core files outside of the broad prefixes
CORE_FILES = (
    # Evaluation & reporting (key entry points)
    "src/invarlock/eval/metrics.py",
    "src/invarlock/reporting/report.py",
    "src/invarlock/reporting/validate.py",
    "src/invarlock/reporting/report_types.py",
    # Certificate is part of the reporting surface but has an explicit
    # transitional override below until tests mature
    "src/invarlock/reporting/certificate.py",
    # Critical CLI commands
    "src/invarlock/cli/commands/run.py",
    "src/invarlock/cli/commands/verify.py",
)


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Enforce per-file coverage floors")
    parser.add_argument(
        "--coverage",
        default="coverage.xml",
        help="Path to coverage XML report (default: coverage.xml)",
    )
    parser.add_argument(
        "--json",
        dest="json_path",
        help="Optional path to write results as JSON",
    )
    parser.add_argument(
        "--core-floor",
        type=float,
        default=CORE_FLOOR_DEFAULT,
        help=f"Branch coverage floor for core modules (default: {CORE_FLOOR_DEFAULT:.0%})",
    )
    parser.add_argument(
        "--default-floor",
        type=float,
        default=DEFAULT_FLOOR_DEFAULT,
        help=(
            "Branch coverage floor for non-core modules (default: 80%). "
            "Note: non-core floors are only applied for files explicitly listed in THRESHOLDS."
        ),
    )
    return parser.parse_args()


def _load_coverage_xml(path: Path) -> ET.Element:
    if not path.exists():
        raise FileNotFoundError(f"Coverage report not found: {path}")
    return ET.parse(path).getroot()


def _collect_branch_rates(root: ET.Element) -> dict[str, float]:
    """Return mapping of normalized file path → branch rate (fallback to line rate).

    Coverage.py emits class-level attributes like 'branch-rate' and 'line-rate'.
    We prefer branch-rate to enforce branch coverage floors, and fall back to
    line-rate if branch-rate is unavailable for a file.
    """

    # Order matters when coverage.xml reports ambiguous bare filenames (e.g.,
    # "bootstrap.py"). Prefer core/reporting over eval so we map to the
    # critical surfaces used in thresholds.
    search_roots = [
        Path("src/invarlock/core"),
        Path("src/invarlock/reporting"),
        Path("src/invarlock/cli"),
        Path("src/invarlock/guards"),
        Path("src/invarlock/eval"),
        Path("scripts"),
    ]

    def _normalize_project_path(path: Path) -> str | None:
        """Return project-relative path starting at src/ or scripts/.

        Coverage XML often emits absolute paths. We want stable keys like
        "src/invarlock/core/runner.py" that match THRESHOLDS. This helper trims any
        absolute prefix up to the first occurrence of "src/" or "scripts/".
        """
        try:
            p = path.resolve()
        except Exception:
            p = path

        # If the path already looks project-relative, keep it
        text = p.as_posix()
        for anchor in ("src/", "scripts/"):
            idx = text.find(anchor)
            if idx != -1:
                return text[idx:]
        # Handle coverage XML that emits package-relative paths like
        # "invarlock/cli/commands/run.py" without the leading "src/" prefix.
        # In that case, restore the expected project-relative prefix.
        if text.startswith("invarlock/"):
            return f"src/{text}"
        # Fallback: if it exists under CWD, try to relativize
        try:
            rel = p.relative_to(Path.cwd())
            return rel.as_posix()
        except Exception:
            return None

    def resolve_path(filename: str) -> str | None:
        # Fast-path: coverage emits package-relative paths like "invarlock/..."
        # Map these directly to project-relative under src/.
        if filename.startswith("invarlock/"):
            return f"src/{filename}"
        candidate = Path(filename)
        # Try normalizing absolute paths first
        if candidate.exists():
            norm = _normalize_project_path(candidate)
            if norm:
                return norm
        # Try joining against known roots
        for root_path in search_roots:
            resolved = root_path / filename
            if resolved.exists():
                norm = _normalize_project_path(resolved)
                if norm:
                    return norm
        return None

    rates: dict[str, float] = {}
    for class_node in root.findall("./packages/package/classes/class"):
        filename = class_node.attrib.get("filename")
        if not filename:
            continue
        # Prefer branch-rate; fallback to line-rate
        rate_str = class_node.attrib.get("branch-rate") or class_node.attrib.get(
            "line-rate"
        )
        try:
            rate = float(rate_str or 0.0)
        except (TypeError, ValueError):
            rate = 0.0
        # Normalize path; some coverage outputs are already project-relative
        # (e.g., "invarlock/cli/commands/run.py")
        norm = resolve_path(filename.replace("\\", "/"))
        if not norm:
            continue
        # Keep the highest rate seen if tool emits duplicates per class
        rates[norm] = max(rate, rates.get(norm, 0.0))
    return rates


def _write_json(json_path: Path, records: list[dict[str, Any]], status: str) -> None:
    payload = {"status": status, "files": records}
    json_path.write_text(json.dumps(payload, indent=2, sort_keys=True) + "\n")


def main() -> int:
    args = _parse_args()
    report_path = Path(args.coverage)
    root = _load_coverage_xml(report_path)
    rates = _collect_branch_rates(root)

    failures: list[str] = []
    records: list[dict[str, Any]] = []

    def _is_core(path: str) -> bool:
        return path in CORE_FILES or any(path.startswith(p) for p in CORE_PREFIXES)

    # Build required floors for core classification only; non-core modules are
    # not globally enforced to avoid over-scoping. Explicit overrides (below)
    # extend this set.
    required: dict[str, float] = {}
    for rel_path in rates.keys():
        if _is_core(rel_path):
            required[rel_path] = args.core_floor

    # Apply explicit overrides (can be lower or higher than the base floor).
    # Only enforce overrides for files that appear in the current report.
    for rel_path, floor in THRESHOLDS.items():
        if rel_path in rates:
            required[rel_path] = floor

    # Evaluate all known files with a required floor
    for rel_path, floor in sorted(required.items()):
        rate = rates.get(rel_path)
        record = {
            "path": rel_path,
            "threshold": floor,
            "coverage": rate,
            "core": _is_core(rel_path),
        }
        records.append(record)
        if rate is None:
            failures.append(f"{rel_path}: no coverage data present")
            continue
        if rate + 1e-9 < floor:
            failures.append(
                f"{rel_path}: coverage {rate:.3%} below required {floor:.0%}"
            )

    if args.json_path:
        _write_json(Path(args.json_path), records, "fail" if failures else "ok")

    if failures:
        for failure in failures:
            print(f"Coverage threshold not met: {failure}", file=sys.stderr)
        return 1

    for rel_path, threshold in THRESHOLDS.items():
        rate = rates.get(rel_path)
        if rate is not None:
            print(f"{rel_path}: {rate:.2%} (branch threshold {threshold:.0%})")
            if threshold < 0.85:
                print(
                    "  note: phased coverage floor – ratchet upward when touching this file"
                )

    summary = (
        f"Coverage OK: {len(THRESHOLDS)}/{len(THRESHOLDS)} files met per-file thresholds. "
        "Project floor (65%) enforced via pytest."
    )
    print(summary)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
